import { SentenceStructureSchema, SentenceStructure } from '../grammar/sentence-structure.schema'; // Import schema and type
import { correctIncorrectErrorService, CorrectIncorrectErrorType } from '../error-generation/correct-incorrect.service'; // Import error service
import { isDebugMode } from '@/lib/utils/debug'; // Import debug utility
import { z } from 'zod';
import { aiService } from '../ai/ai.service';
import { moduleRegistryService } from '../registry/module-registry.service';
import { modalSchemaRegistryService } from '../modals/registry.service';
import { structureConstraintService, GenerationConstraints, VocabTypeConstraint } from './structure-constraint.service'; // Import constraint service and renamed type
import { vocabularyService, VocabularyItem } from '../vocabulary/vocabulary.service'; // Import vocab service
import { ModuleDefinition, SubmoduleDefinition } from '@/lib/learning/types';
import { ModalSchemaDefinition } from '@/lib/learning/modals/types';

const DEBUG_GENERATION = isDebugMode('GENERATION');

// Define schemas for modals handled explicitly
const TrueFalseSchema = z.object({
  statement: z.string().describe("The true/false statement to present to the user."),
  isCorrectAnswerTrue: z.boolean().describe("The boolean correct answer (true if the statement is true, false otherwise)."),
  explanation: z.string().describe("A brief explanation why the statement is true or false. Return an empty string (\"\") if no specific explanation is needed.")
});

const MultipleChoiceSchema = z.object({
  question: z.string().describe("The main multiple-choice question text (e.g., 'Which ending fits?')."),
  sentence: z.string().describe("The COMPLETE example sentence generated by the AI."),
  targetWordBase: z.string().describe("The base form (lemma) of the word whose ending is being tested, e.g., 'sch√∂n'."),
  options: z.array(z.string()).length(4).describe("An array containing exactly 4 distinct ENDING strings (e.g., 'e', 'en', 'es')."),
  correctOptionIndex: z.number().int().min(0).max(3).describe("The 0-based index of the correct ENDING option in the options array."),
  explanation: z.string().describe("A brief explanation why the correct answer is right. Return an empty string (\"\") if no specific explanation is needed.")
});

const FillInGapSchema = z.object({
    sentenceTemplate: z.string().describe("The sentence containing exactly one blank represented by '___'."),
    correctAnswer: z.string().describe("The single word or short phrase that correctly fills the blank."),
    acceptedAnswers: z.array(z.string()).describe("Optional list of other acceptable answers (strings). Return an empty array ([]) if none."),
    explanation: z.string().describe("An optional brief explanation related to the grammar point or vocabulary. Return an empty string (\"\") if no specific explanation is needed.")
});

// Exporting types might be useful elsewhere
export type TrueFalseQuestion = z.infer<typeof TrueFalseSchema>;
export type MultipleChoiceQuestion = z.infer<typeof MultipleChoiceSchema>;
export type FillInGapQuestion = z.infer<typeof FillInGapSchema>;

// Define the return type for generation
export interface GenerationResult {
    questionData: any;
    debugInfo?: {
        constraints: GenerationConstraints;
        requiredVocab: Record<string, VocabularyItem[]>;
        enhancedPrompt?: string; // Optionally include the prompt
    } | null;
}

interface GenerateQuestionParams {
  moduleId: string; // Keep for potential context, though definition is passed
  submoduleId: string; // Keep for potential context
  modalSchemaId: string; // Keep for potential context
  
  // Pass the actual definitions to avoid re-fetching
  moduleDefinition: ModuleDefinition;
  submoduleDefinition: SubmoduleDefinition;
  modalSchemaDefinition: ModalSchemaDefinition;
  
  targetLanguage: string;
  sourceLanguage: string;
  difficulty?: 'beginner' | 'intermediate' | 'advanced';
  forcedConstraints?: GenerationConstraints; // Add optional forced constraints
}

export class QuestionGenerationService {

  constructor() {
    moduleRegistryService.initialize().catch(err => console.error("Failed to init ModuleRegistry in Generator", err));
    modalSchemaRegistryService.initialize().catch(err => console.error("Failed to init ModalSchemaRegistry in Generator", err));
  }

  async generateQuestion(params: GenerateQuestionParams): Promise<GenerationResult> {
    const { 
      moduleId, submoduleId, modalSchemaId, // Keep IDs for logging/context
      moduleDefinition: module, // Rename for clarity
      submoduleDefinition: submodule, // Rename for clarity
      modalSchemaDefinition: modalSchema, // Rename for clarity
      targetLanguage, 
      sourceLanguage, 
      difficulty = 'beginner', 
      forcedConstraints 
    } = params;

    if (DEBUG_GENERATION) console.log(`[Generator Debug] Start Generation: ${moduleId}/${submoduleId}/${modalSchemaId}`);

    // --- 1. Use Passed Definitions & Context --- 
    // const module = moduleRegistryService.getModule(moduleId); // REMOVED
    // const submodule = module?.submodules.find(sub => sub.id === submoduleId); // REMOVED
    // const modalSchema = modalSchemaRegistryService.getSchema(modalSchemaId); // REMOVED
    
    // Validation: Ensure the passed definitions are valid
    if (!module || !submodule || !modalSchema) {
      // This should ideally not happen if the API route validates first, but good practice
      throw new Error(`Invalid definitions passed to generateQuestion for ${moduleId}/${submoduleId}/${modalSchemaId}`);
    }
    
    // Check if submodule supports the modal schema (remains valid)
    if (!submodule.supportedModalSchemaIds?.includes(modalSchemaId)) {
      throw new Error(`Submodule ${submoduleId} does not support modal schema ${modalSchemaId}`);
    }

    // --- Resolve Overrides (Submodule > Module > Modal Default) --- 
    const submoduleOverride = submodule.overrides?.[modalSchemaId];
    const moduleOverride = module.moduleOverrides?.[modalSchemaId]; // Use moduleOverrides
    const modalDefault = modalSchema.generationConfig;

    // Determine final prompt template
    const basePromptTemplate = 
        submoduleOverride?.generationPromptOverride ?? 
        moduleOverride?.generationPromptOverride ?? 
        modalDefault.promptTemplate;
        
    // Determine allowed error types (relevant for sentence-error-*)
    const allowedErrorTypes = 
        submoduleOverride?.allowedErrorTypes ?? 
        moduleOverride?.allowedErrorTypes ?? 
        []; // Default to empty if not defined anywhere
        
    // Note: uiComponent override is handled by the API route, not needed here.

    const baseGenerationContext = {
      targetLanguage,
      sourceLanguage,
      difficulty,
      submoduleContext: typeof submodule.submoduleContext === 'string' ? submodule.submoduleContext : JSON.stringify(submodule.submoduleContext),
      // Add allowedErrorTypes to context if needed by prompts (might not be necessary)
      // allowedErrorTypesContext: allowedErrorTypes.join(', ') 
    };

    // --- Declare variables needed in multiple scopes --- 
    let finalPrompt: string;
    let determinedConstraints: GenerationConstraints | null = null;
    let fetchedVocab: Record<string, VocabularyItem[]> = {};
    let schemaToUse: z.ZodType<any, any> | null = null;
    let schemaDescription: string = `Schema ID: ${modalSchemaId}`;
    let questionData: any | null = null;

    // --- 2. Determine Constraints and Fetch Vocabulary --- 
    determinedConstraints = forcedConstraints ?? structureConstraintService.getConstraints({ language: targetLanguage, difficulty, submodule });
    if (DEBUG_GENERATION) console.log(`[Generator Debug] Using constraints:`, determinedConstraints);

    let allVocabFetched = true; // Flag to track if all requests were successful
    if (determinedConstraints.posConstraints.length > 0) {
        fetchedVocab = await this.fetchRequiredVocabulary(determinedConstraints, targetLanguage);
        // Check if WE REQUESTED items but GOT NONE overall
        if (Object.keys(fetchedVocab).length === 0) {
             console.error(`[Generator] CRITICAL: Failed to fetch ANY required vocabulary for constraints:`, determinedConstraints.posConstraints);
             throw new Error("Failed to fetch any required vocabulary."); // Maybe throw an error here
        }
        // Check if we got less than requested for ANY category
        for (const constraint of determinedConstraints.posConstraints) {
            if ((fetchedVocab[constraint.pos]?.length ?? 0) < constraint.count) {
                allVocabFetched = false;
                if (DEBUG_GENERATION) console.log(`[Generator Debug] Partial vocab fetch for ${constraint.pos}: got ${fetchedVocab[constraint.pos]?.length ?? 0}/${constraint.count}`);
            }
        }
        if (!allVocabFetched) {
            console.warn("[Generator] Vocabulary fetch was incomplete, proceeding with available words.");
        }
    }

    // --- 3. Assemble Final Prompt --- 
    // Always use the enhanced prompt structure now, even if vocab is partial/empty
    
    // Format the vocab list clearly: "TYPE: word1, word2; TYPE2: word3..."
    const vocabListString = Object.entries(fetchedVocab)
        .map(([vocabType, items]) => 
            `${vocabType}: ${items.map(item => item.word).join(', ')}`
        )
        .join('; ') || 'any appropriate words satisfying the constraints';

    const structureDesc = this.describeStructuralConstraints(determinedConstraints);
    const promptContext = { 
        ...baseGenerationContext, 
        requiredVocabList: vocabListString, // Use the new formatted string
        structuralConstraintsDescription: structureDesc 
    };
    finalPrompt = this.replacePlaceholders(basePromptTemplate, promptContext);
    
    if (DEBUG_GENERATION) {
        console.log(`[Generator Debug] Final Prompt Context:`, promptContext);
        console.log(`[Generator Debug] Final Prompt: ${finalPrompt.substring(0, 300)}...`);
    }

    // --- 4. Route based on modalSchemaId & Call AI --- 
    try {
        if (modalSchemaId === 'sentence-error-identify' || modalSchemaId === 'sentence-error-replace') {
            schemaToUse = SentenceStructureSchema;
            schemaDescription = 'SentenceStructureSchema';
            const taskType = modalSchemaId === 'sentence-error-identify' ? 'identify' : 'replace';
            // Ensure constraints are not null for this path
            if (!determinedConstraints) throw new Error("Constraints required for sentence-error generation but were not available.");
            // Note: generateSentenceErrorQuestion calls AI service internally
            questionData = await this.generateSentenceErrorQuestion(finalPrompt, targetLanguage, submodule, taskType, modalSchemaId, determinedConstraints, fetchedVocab, allowedErrorTypes);

        } else if (modalSchemaId === 'true-false') {
             schemaToUse = TrueFalseSchema;
             schemaDescription = 'TrueFalseSchema';
             questionData = await aiService.generateStructuredData(finalPrompt, schemaToUse, schemaDescription);
        
        } else if (modalSchemaId === 'multiple-choice') {
             schemaToUse = MultipleChoiceSchema;
             schemaDescription = 'MultipleChoiceSchema';
             questionData = await aiService.generateStructuredData(finalPrompt, schemaToUse, schemaDescription); 

        } else if (modalSchemaId === 'fill-in-gap') {
             schemaToUse = FillInGapSchema;
             schemaDescription = 'FillInGapSchema';
             questionData = await aiService.generateStructuredData(finalPrompt, schemaToUse, schemaDescription);

        } else {
             // Fallback
             if (DEBUG_GENERATION) console.log(`[Generator Debug] Using FALLBACK AI flow for schema ${modalSchemaId}.`);
             schemaDescription = `Fallback (z.any())`;
             // Use z.any() for fallback, passing a description
             questionData = await aiService.generateStructuredData(finalPrompt, z.any(), schemaDescription);
             determinedConstraints = null; // Ensure no debug info for fallback
             fetchedVocab = {};
             if (!questionData) console.error(`[Generator] Fallback flow failed for ${modalSchemaId}.`);
        }

        if (!questionData) { throw new Error(`AI service returned null data for schema ${modalSchemaId}.`); }
        
        // --- 5. Construct Final Result --- 
        return {
            questionData,
            // Use determinedConstraints used for the attempt, even if vocab was partial
            debugInfo: determinedConstraints 
                ? { constraints: determinedConstraints, requiredVocab: fetchedVocab, enhancedPrompt: finalPrompt } 
                : null // Should ideally not be null now unless no constraints were generated
        };

    } catch (error: unknown) {
        this.handleGenerationError(error, finalPrompt, schemaDescription);
    }
  }

  /**
   * Fetches the required vocabulary items based on constraints.
   */
  private async fetchRequiredVocabulary(constraints: GenerationConstraints, language: string): Promise<Record<string, VocabularyItem[]>> {
      const fetchedVocab: Record<string, VocabularyItem[]> = {};
      if (DEBUG_GENERATION) console.log(`[Generator Debug] Fetching vocabulary for constraints:`, constraints.posConstraints);
      
      for (const constraint of constraints.posConstraints) {
          const { pos, count } = constraint;
          if (count > 0) {
              const criteria = {
                  language: language,
                  limit: count,
                  pos: [pos],
                  themes: constraints.vocabularyTheme ? [constraints.vocabularyTheme] : undefined,
                  cefrLevel: undefined
              };
              if (DEBUG_GENERATION) console.log(`[Generator Debug] Calling vocabularyService.getVocabularyItems with criteria:`, criteria);
              
              const items = await vocabularyService.getVocabularyItems(criteria);
              if (items.length < count) {
                  console.warn(`[Generator] Could only fetch ${items.length}/${count} items for POS: ${pos}`);
              }
              if (items.length > 0) {
                 fetchedVocab[pos] = items;
              }
          }
      }
      if (DEBUG_GENERATION) console.log(`[Generator Debug] Fetched vocabulary results:`, fetchedVocab);
      return fetchedVocab;
  }
  
  /** Helper to create a string description of structural constraints */
  private describeStructuralConstraints(constraints: GenerationConstraints): string {
      let desc = "The sentence structure should adhere to the following: ";
      desc += `Exactly ${constraints.numClauses} clause(s). `;
      if (constraints.numRelativeClauses && constraints.numRelativeClauses > 0) {
          desc += `${constraints.numRelativeClauses} should be relative clause(s). `;
      }
      desc += `Sentence type should be a ${constraints.sentenceType}. `;
      // Can add more details based on posConstraints if needed
      return desc;
  }

  /**
   * Handles sentence error generation - Refine AI call logic
   */
  private async generateSentenceErrorQuestion(
      finalPrompt: string, // Now receives the fully assembled prompt
      language: string, 
      submodule: any, // TODO: Type this better if possible (SubmoduleDefinition)
      taskType: 'identify' | 'replace', 
      modalSchemaId: string, 
      constraints: GenerationConstraints, 
      requiredVocab: Record<string, VocabularyItem[]>, 
      allowedErrorTypes: CorrectIncorrectErrorType[] // Add parameter here
    ): Promise<any> { 
      if (DEBUG_GENERATION) console.log(`[Generator Debug] Starting sentence-error flow (Task: ${taskType}, Modal: ${modalSchemaId}). Allowed Errors: ${allowedErrorTypes.join(', ')}`);
      
      // 1. Generate the CORRECT sentence structure using AI with the FINAL prompt
      // The prompt already includes vocab/structure constraints
      const correctStructure = await aiService.generateStructuredData(finalPrompt, SentenceStructureSchema, 'SentenceStructureSchema');
      if (!correctStructure) throw new Error('AI failed to generate valid sentence structure from final prompt.');
      if (DEBUG_GENERATION) console.log(`[Generator Debug] Received correct sentence structure:`, JSON.stringify(correctStructure, null, 2));
      
      // 2. Apply errors (logic remains the same)
      const maxErrors = 1; 
      if (DEBUG_GENERATION) console.log(`[Generator Debug] Applying errors with types: ${allowedErrorTypes.join(', ')}`); // Log resolved error types
      
      const { modifiedStructure, presentedSentence, errorsIntroduced } = await correctIncorrectErrorService.generateErrors({
          sentenceStructure: correctStructure, allowedErrorTypes, maxErrors, language
      });
      
      if (errorsIntroduced.length === 0) {
          console.warn("[Generator] No errors could be introduced. Returning original as 'confirm' task.");
           return {
              presentedSentence: correctStructure.originalSentence,
              isCorrect: true, 
              taskType: 'confirm',
              correctSentence: correctStructure.originalSentence,
              incorrectSegments: [], 
              sentenceStructure: correctStructure 
          };
      }

      const questionData = {
          presentedSentence: presentedSentence,
          correctSentence: correctStructure.originalSentence,
          incorrectSegments: errorsIntroduced.map(err => err.modifiedText), 
          taskType: taskType,
          sentenceStructure: modifiedStructure, 
          originalStructure: correctStructure,
          errorsIntroduced: errorsIntroduced 
      };

      if (DEBUG_GENERATION) console.log(`[Generator Debug] Final questionData for ${taskType}:`, JSON.stringify(questionData, null, 2));
      return questionData;
  }

  private handleGenerationError(error: unknown, prompt: string, schemaContext: string): never {
    console.error("Error during question generation:", error);
    console.error("Prompt used:", prompt);
    console.error("Schema Context:", schemaContext);
    throw new Error(`Failed to generate question data. AI Error: ${(error instanceof Error ? error.message : String(error))}`);
  }

  /**
   * Replace placeholders in a prompt template with actual values.
   */
  private replacePlaceholders(template: string, values: Record<string, any>): string {
    let result = template;
    
    if (DEBUG_GENERATION) console.log("[Generator Debug/Replace] START - Template:", template.substring(0, 150) + "...");
    if (DEBUG_GENERATION) console.log("[Generator Debug/Replace] START - Values:", values);

    // Explicitly replace known placeholders, checking if value exists
    const replaceIfPresent = (key: string, value: any) => {
        if (value !== undefined && value !== null) {
            const regex = new RegExp(`{${key}}`, 'g');
            const replacement = String(value);
            if (DEBUG_GENERATION) console.log(`[Generator Debug/Replace] Replacing {${key}} with: ${replacement.substring(0, 50)}...`);
            result = result.replace(regex, replacement);
        } else {
            // Handle specific defaults for missing values if needed
             if (key === 'requiredVocabList') {
                 if (DEBUG_GENERATION) console.log(`[Generator Debug/Replace] Placeholder {${key}} missing, using default.`);
                 result = result.replace(/{requiredVocabList}/g, 'any appropriate words');
             } else if (key === 'structuralConstraintsDescription') {
                  if (DEBUG_GENERATION) console.log(`[Generator Debug/Replace] Placeholder {${key}} missing, replacing with empty.`);
                  result = result.replace(/{structuralConstraintsDescription}/g, '');
             } else {
                  if (DEBUG_GENERATION) console.log(`[Generator Debug/Replace] Placeholder {${key}} missing, replacing with empty.`);
                  result = result.replace(new RegExp(`{${key}}`, 'g'), '');
             }
        }
    }

    replaceIfPresent('targetLanguage', values.targetLanguage);
    replaceIfPresent('sourceLanguage', values.sourceLanguage);
    replaceIfPresent('difficulty', values.difficulty);
    replaceIfPresent('submoduleContext', values.submoduleContext);
    replaceIfPresent('requiredVocabList', values.requiredVocabList);
    replaceIfPresent('structuralConstraintsDescription', values.structuralConstraintsDescription);
    // Add calls for any other placeholders defined in prompts

    if (DEBUG_GENERATION) console.log("[Generator Debug/Replace] END - Result:", result.substring(0, 300) + "...");
    return result;
  }
}

export const questionGenerationService = new QuestionGenerationService(); 
console.log("DEBUG: question-generation.service.ts loaded");
